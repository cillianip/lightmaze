<!DOCTYPE html>
<html>
<head>
    <title>Ray Test</title>
    <style>
        body { margin: 0; background: #000; color: #fff; font-family: monospace; }
        canvas { border: 1px solid #333; display: block; margin: 20px auto; }
        #info { text-align: center; margin: 10px; }
    </style>
</head>
<body>
    <div id="info">Click to rotate mirror</div>
    <canvas id="canvas" width="800" height="600"></canvas>
    <script>
        // Simple inline test without modules
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        
        // Vector2 class
        class Vector2 {
            constructor(x, y) {
                this.x = x;
                this.y = y;
            }
            
            add(v) {
                return new Vector2(this.x + v.x, this.y + v.y);
            }
            
            subtract(v) {
                return new Vector2(this.x - v.x, this.y - v.y);
            }
            
            multiply(scalar) {
                return new Vector2(this.x * scalar, this.y * scalar);
            }
            
            dot(v) {
                return this.x * v.x + this.y * v.y;
            }
            
            length() {
                return Math.sqrt(this.x * this.x + this.y * this.y);
            }
            
            normalize() {
                const len = this.length();
                if (len === 0) return new Vector2(0, 0);
                return new Vector2(this.x / len, this.y / len);
            }
            
            reflect(normal) {
                // r = d - 2(dÂ·n)n
                return this.subtract(normal.multiply(2 * this.dot(normal)));
            }
        }
        
        // Simple ray tracing
        let mirrorAngle = Math.PI / 4;
        const lightPos = new Vector2(100, 300);
        const mirrorPos = new Vector2(400, 300);
        const crystalPos = new Vector2(700, 300);
        
        function drawScene() {
            // Clear
            ctx.fillStyle = '#0a0a0a';
            ctx.fillRect(0, 0, 800, 600);
            
            // Grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let x = 0; x <= 800; x += 40) {
                ctx.beginPath();
                ctx.moveTo(x, 0);
                ctx.lineTo(x, 600);
                ctx.stroke();
            }
            for (let y = 0; y <= 600; y += 40) {
                ctx.beginPath();
                ctx.moveTo(0, y);
                ctx.lineTo(800, y);
                ctx.stroke();
            }
            
            // Light source
            ctx.fillStyle = '#00ffff';
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            ctx.arc(lightPos.x, lightPos.y, 8, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Mirror
            ctx.save();
            ctx.translate(mirrorPos.x, mirrorPos.y);
            ctx.rotate(mirrorAngle);
            ctx.strokeStyle = '#ffffff';
            ctx.lineWidth = 4;
            ctx.lineCap = 'round';
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ffffff';
            ctx.beginPath();
            ctx.moveTo(-30, 0);
            ctx.lineTo(30, 0);
            ctx.stroke();
            ctx.restore();
            
            // Crystal
            ctx.strokeStyle = '#ff00ff';
            ctx.fillStyle = 'rgba(255, 0, 255, 0.3)';
            ctx.lineWidth = 2;
            ctx.shadowBlur = 10;
            ctx.shadowColor = '#ff00ff';
            ctx.beginPath();
            ctx.moveTo(crystalPos.x, crystalPos.y - 12);
            ctx.lineTo(crystalPos.x + 10, crystalPos.y);
            ctx.lineTo(crystalPos.x, crystalPos.y + 12);
            ctx.lineTo(crystalPos.x - 10, crystalPos.y);
            ctx.closePath();
            ctx.fill();
            ctx.stroke();
            ctx.shadowBlur = 0;
            
            // Cast ray
            const rayDir = new Vector2(1, 0); // Horizontal ray
            
            // Draw ray from light to mirror
            ctx.strokeStyle = '#00ffff';
            ctx.lineWidth = 3;
            ctx.shadowBlur = 20;
            ctx.shadowColor = '#00ffff';
            ctx.beginPath();
            ctx.moveTo(lightPos.x, lightPos.y);
            ctx.lineTo(mirrorPos.x, mirrorPos.y);
            ctx.stroke();
            
            // Calculate reflection
            const mirrorNormal = new Vector2(-Math.sin(mirrorAngle), Math.cos(mirrorAngle));
            const incidentRay = new Vector2(mirrorPos.x - lightPos.x, mirrorPos.y - lightPos.y).normalize();
            const reflectedRay = incidentRay.reflect(mirrorNormal);
            
            // Draw reflected ray
            const endPoint = mirrorPos.add(reflectedRay.multiply(300));
            ctx.beginPath();
            ctx.moveTo(mirrorPos.x, mirrorPos.y);
            ctx.lineTo(endPoint.x, endPoint.y);
            ctx.stroke();
            
            // Check if ray hits crystal
            const toCrystal = crystalPos.subtract(mirrorPos);
            const rayLength = toCrystal.length();
            const normalizedToCrystal = toCrystal.normalize();
            const dot = normalizedToCrystal.dot(reflectedRay);
            
            if (dot > 0.9) { // Ray is pointing towards crystal
                const dist = Math.abs(toCrystal.x * reflectedRay.y - toCrystal.y * reflectedRay.x);
                if (dist < 15) {
                    // Crystal is hit - make it glow
                    ctx.strokeStyle = '#00ff00';
                    ctx.fillStyle = 'rgba(0, 255, 0, 0.5)';
                    ctx.shadowColor = '#00ff00';
                    ctx.shadowBlur = 30;
                    ctx.beginPath();
                    ctx.moveTo(crystalPos.x, crystalPos.y - 12);
                    ctx.lineTo(crystalPos.x + 10, crystalPos.y);
                    ctx.lineTo(crystalPos.x, crystalPos.y + 12);
                    ctx.lineTo(crystalPos.x - 10, crystalPos.y);
                    ctx.closePath();
                    ctx.fill();
                    ctx.stroke();
                }
            }
            
            ctx.shadowBlur = 0;
        }
        
        // Animation loop
        function animate() {
            drawScene();
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Click to rotate mirror
        canvas.addEventListener('click', () => {
            mirrorAngle += Math.PI / 4;
            if (mirrorAngle >= Math.PI * 2) {
                mirrorAngle = 0;
            }
        });
    </script>
</body>
</html>